(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{424:function(v,_,a){"use strict";a.r(_);var r=a(2),e=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"目录"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[v._v("#")]),v._v(" 目录")]),v._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"#%E4%BD%9C%E8%80%85%E4%BB%8B%E7%BB%8D"}},[v._v("作者介绍")])]),v._v(" "),_("li",[_("a",{attrs:{href:"#%E6%A6%82%E8%BF%B0"}},[v._v("概述")])]),v._v(" "),_("li",[_("a",{attrs:{href:"#%E5%9C%A8%E5%BC%80%E5%A7%8B%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%89%8D"}},[v._v("在开始机器学习之前")])]),v._v(" "),_("li",[_("a",{attrs:{href:"#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9D%A1%E7%AE%A1%E9%81%93"}},[v._v("机器学习的第一阶段：你的第一条管道")]),v._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"#%E6%A8%A1%E5%9E%8B%E7%9B%91%E6%8E%A7"}},[v._v("模型监控")])]),v._v(" "),_("li",[_("a",{attrs:{href:"#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9B%AE%E6%A0%87"}},[v._v("第一个目标")])])])]),v._v(" "),_("li",[_("a",{attrs:{href:"#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5-%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B"}},[v._v("机器学习的第二阶段：特征工程")]),v._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"#%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BA%BA%E5%B7%A5%E5%88%86%E6%9E%90"}},[v._v("系统的人工分析")])]),v._v(" "),_("li",[_("a",{attrs:{href:"#%E8%AE%AD%E7%BB%83%E5%81%8F%E5%B7%AE-training-serving-skew"}},[v._v("训练偏差")])])])]),v._v(" "),_("li",[_("a",{attrs:{href:"#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5-%E7%BC%93%E6%85%A2%E6%8F%90%E5%8D%87%E3%80%81%E7%B2%BE%E7%BB%86%E4%BC%98%E5%8C%96%E3%80%81%E5%A4%8D%E6%9D%82%E6%A8%A1%E5%9E%8B"}},[v._v("机器学习的第三阶段：缓慢提升、精细优化、复杂模型")])]),v._v(" "),_("li",[_("a",{attrs:{href:"#%E6%80%BB%E7%BB%93"}},[v._v("总结")])])]),v._v(" "),_("p",[v._v("本文旨在指引具有机器学习基础知识的工程师等人，更好的从机器学习的实践中收益。介绍一些应用机器学习需要遵循的规则（43个），类似于Google C++ 风格指南等流行的编程指南。\n作者认为机器学习在实际工作确实更多是工程问题，而不是算法问题。优先从工程效率中要效果，当把这部分榨干后，再考虑算法的升级。")]),v._v(" "),_("h2",{attrs:{id:"作者介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作者介绍"}},[v._v("#")]),v._v(" 作者介绍")]),v._v(" "),_("p",[v._v("Martin Zinkevich是谷歌大脑的高级科学家，负责和参与了YouTube、Google Play 以及Google Plus等产品中的机器学习项目。在加入谷歌之前是雅虎的高级科学家，曾在2010年和2011年两度获得雅虎的最高荣誉Yahoo Team Superstar Awards，对雅虎的广告系统做出过很多杰出贡献。")]),v._v(" "),_("h2",{attrs:{id:"术语"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#术语"}},[v._v("#")]),v._v(" 术语")]),v._v(" "),_("p",[v._v("文章中以下术语会反复出现：")]),v._v(" "),_("ul",[_("li",[v._v("实例：需要要对其进行预测的事物。例如，该实例可能是您想要分类为“关于猫”或“不是关于猫”的网页。")]),v._v(" "),_("li",[v._v("标签：预测任务的答案，可以是机器学习系统产生的答案，也可以是训练数据中提供的正确答案。例如，网页的标签可能是“关于猫”。")]),v._v(" "),_("li",[v._v("特征：预测任务中使用的实例的属性。例如，网页可能具有“包含单词 cat”的特征。")]),v._v(" "),_("li",[v._v("特征列：一组相关的特征，例如用户可能居住的所有可能国家的集合。一个示例可能在特征列中存在一个或多个特征，或者称为字段或变量。")]),v._v(" "),_("li",[v._v("样本：一个实例（及其特征）和一个标签。")]),v._v(" "),_("li",[v._v("模型：预测任务的统计表示。您根据样本训练模型，然后使用该模型进行预测。")]),v._v(" "),_("li",[v._v("评价标准(Metric)：一个你关心的数字。可能是也可能不是直接优化的指标。")]),v._v(" "),_("li",[v._v("目标(Objective)：你的算法试图优化的一个指标。")]),v._v(" "),_("li",[v._v("管道(pipeline)：围绕机器学习算法流程搭建的流水线。包括从前端收集数据，将其放入训练数据文件/数据库，训练一个或多个模型，并将模型输出到生产。")]),v._v(" "),_("li",[v._v("点击率：一个网页的访问者点击广告链接的百分比。")])]),v._v(" "),_("h2",{attrs:{id:"概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[v._v("#")]),v._v(" 概述")]),v._v(" "),_("p",[v._v("要做出好的产品："),_("strong",[v._v("建议借鉴用优秀工程师的做法去做机器学习")]),v._v("。")]),v._v(" "),_("p",[v._v("你将面对的大多数问题事实上是工程问题。即使让所有优秀的机器学习专家来做，性能的提升大多还是来自好的特征，而不是好的机器学习算法。所以，基本的方法是：")]),v._v(" "),_("ol",[_("li",[v._v("确保管道可靠。")]),v._v(" "),_("li",[v._v("开始于一个合理（reasonable）的目标。")]),v._v(" "),_("li",[v._v("用直观简单的方式添加经验性的特征。")]),v._v(" "),_("li",[v._v("确认管道依然可靠。")])]),v._v(" "),_("p",[v._v("当没有简单的方法可以使用了的时候，需要使用一些尖端的机器学习方法，可以参考第三部分。")]),v._v(" "),_("p",[v._v("这篇文章将会分为四个部分：")]),v._v(" "),_("ol",[_("li",[v._v("第一部分将帮助你理解是否需要建立一个机器学习系统。")]),v._v(" "),_("li",[v._v("第二部分关于部署你的第一个管道（Pipeline）。")]),v._v(" "),_("li",[v._v("第三部分关于系统的启动，当新特征加入系统时迭代，如何评估模型及训练和服务之间的偏差。")]),v._v(" "),_("li",[v._v("最后关于当系统停滞不前该如何处理。")])]),v._v(" "),_("h2",{attrs:{id:"在开始机器学习之前"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#在开始机器学习之前"}},[v._v("#")]),v._v(" 在开始机器学习之前")]),v._v(" "),_("h4",{attrs:{id:"rule-1-不要害怕在没有机器学习技术参与的情况下启动一个产品-项目"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-1-不要害怕在没有机器学习技术参与的情况下启动一个产品-项目"}},[v._v("#")]),v._v(" Rule #1： 不要害怕在没有机器学习技术参与的情况下启动一个产品/项目")]),v._v(" "),_("p",[v._v("机器学习很酷，但它需要数据。理论上，你可以从不同的问题中获取数据，然后为新产品调整模型，但这很可能会比基本的启发式（基线）方法表现得差。如果你认为机器学习会给你带来100%的提升，那么启发式方法也可能会让你达到50%的效果。")]),v._v(" "),_("p",[v._v("例如，如果你在应用市场上对app进行排名，你可以使用安装率或安装次数作为启发式方法。如果你检测的是垃圾邮件，那么就过滤掉那些曾经发送过垃圾邮件的发布者。也不要害怕使用人工编辑。如果你需要对联系人进行排名，那就把最近使用的人排到最高（甚至按字母顺序排）。如果机器学习对你的产品不是绝对必要的，在你有数据之前不要使用它。")]),v._v(" "),_("h4",{attrs:{id:"rule-2-在动手之前先设计和实现评价指标"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-2-在动手之前先设计和实现评价指标"}},[v._v("#")]),v._v(" Rule #2： 在动手之前先设计和实现评价指标")]),v._v(" "),_("p",[v._v("在构建具体的机器学习系统之前，首先在当前系统中记录尽量详细的历史信息，留好特征数据。这样不仅能够留好特征数据，还能够帮助我们随时了解系统的状态，以及做各种改动时系统的变化。")]),v._v(" "),_("h4",{attrs:{id:"rule-3-当规则过于复杂时-请使用机器学习系统"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-3-当规则过于复杂时-请使用机器学习系统"}},[v._v("#")]),v._v(" Rule #3：当规则过于复杂时，请使用机器学习系统")]),v._v(" "),_("p",[v._v("简单来讲，复杂的规则系统难以维护，不可扩展，而我们很简单就可以转为ML系统，变得可维护可扩展。")]),v._v(" "),_("h2",{attrs:{id:"机器学习的第一阶段-你的第一条管道"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#机器学习的第一阶段-你的第一条管道"}},[v._v("#")]),v._v(" 机器学习的第一阶段：你的第一条管道")]),v._v(" "),_("p",[v._v("构建第一个机器学习系统时，一定要更多关注系统架构的建设。虽然机器学习的算法令人激动，但是基础架构不给力且找不到问题时会令人抓狂。")]),v._v(" "),_("h4",{attrs:{id:"rule-4-初版模型要简单-主要任务是确定系统流程的正确性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-4-初版模型要简单-主要任务是确定系统流程的正确性"}},[v._v("#")]),v._v(" Rule #4: 初版模型要简单，主要任务是确定系统流程的正确性")]),v._v(" "),_("p",[v._v("第一版模型的核心思想是抓住主要特征、与应用尽量贴合以及快速上线。")]),v._v(" "),_("h4",{attrs:{id:"rule-5-独立于机器学习的测试架构流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-5-独立于机器学习的测试架构流程"}},[v._v("#")]),v._v(" Rule #5: 独立于机器学习的测试架构流程")]),v._v(" "),_("p",[v._v("确保架构是可单独测试的，将系统的训练部分进行封装，以确保其他部分都是可测试的。特别来讲：")]),v._v(" "),_("ul",[_("li",[v._v("测试数据是否正确进入训练算法。检查具体的特征值是否符合预期。")]),v._v(" "),_("li",[v._v("测试实验环境给出的预测结果与线上预测结果是否一致。")])]),v._v(" "),_("h4",{attrs:{id:"rule-6-复制pipeline时要注意丢弃的数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-6-复制pipeline时要注意丢弃的数据"}},[v._v("#")]),v._v(" Rule #6: 复制pipeline时要注意丢弃的数据")]),v._v(" "),_("p",[v._v("从一个场景复制数据到另一个场景时，要注意两边对数据的要求是否一致，是否有数据丢失的情况。")]),v._v(" "),_("h4",{attrs:{id:"rule-7-将启发规则转化为特征-或者在外部处理它们"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-7-将启发规则转化为特征-或者在外部处理它们"}},[v._v("#")]),v._v(" Rule #7: 将启发规则转化为特征，或者在外部处理它们")]),v._v(" "),_("p",[v._v("机器学习系统解决的问题通常都不是新问题，而是对已有问题的进一步优化。这意味着有很多已有的规则或者启发式规则可供使用。这部分信息应该被充分利用（例如基于规则的推荐排序时用到的排序规则）。下面是几种启发式规则可以被使用的方式：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("用启发规则进行预处理。")]),v._v(" 如果启发式规则非常有用，可以这么用。例如在垃圾邮件识别中，如果有发件人已经被拉黑了，那么就不要再去学“拉黑”意味着什么，直接拉黑就好了。")]),v._v(" "),_("li",[_("strong",[v._v("制造特征。")]),v._v(" 可以考虑从启发式规则直接制造一个特征。例如，你使用启发式规则来计算query的相关性，那么就可以把这个相关性得分作为特征使用。后面也可以考虑将计算相关性得分的原始数据作为特征，以期获得更多的信息。")]),v._v(" "),_("li",[_("strong",[v._v("挖掘启发式规则的原始输入。")]),v._v(" 如果有一个app的规则启发式规则综合了下载数、标题文字长度等信息，可以考虑将这些原始信息单独作为特征使用。")]),v._v(" "),_("li",[_("strong",[v._v("修改label。")]),v._v(" 当你觉得启发式规则中包含了样本中没有包含的信息时可以这么用。例如，如果你想最大化下载数，同时还想要追求下载内容的质量。一种可行的方法是将label乘以app的平均star数。在电商领域，也常常用类似的方法，例如在点击率预估的项目中，可考虑对最终下单的商品或者高质量的商品对应的样本增加权重。")])]),v._v(" "),_("p",[v._v("已有的启发式规则可以帮助机器学习系统更平滑的过渡，但是也要考虑是否有同等效果更简单的实现方式。")]),v._v(" "),_("h3",{attrs:{id:"模型监控"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模型监控"}},[v._v("#")]),v._v(" 模型监控")]),v._v(" "),_("h4",{attrs:{id:"rule-8-确定业务系统对时效性的要求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-8-确定业务系统对时效性的要求"}},[v._v("#")]),v._v(" Rule #8: 确定业务系统对时效性的要求")]),v._v(" "),_("p",[v._v("如果模型延迟一天更新，你的系统会受到多大的效果影响？如果是一周的延迟呢？或者更久？这个信息可以让我们排布监控的优先级。如果模型一天不更新收入就会下降10%，那么可以考虑让一个工程师全天候监控它。了解系统对时效性的要求是决定具体监控方案的第一步。")]),v._v(" "),_("h4",{attrs:{id:"rule-9-在模型上线之前检测问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-9-在模型上线之前检测问题"}},[v._v("#")]),v._v(" Rule #9: 在模型上线之前检测问题")]),v._v(" "),_("p",[v._v("模型上线前一定要做完整性、正确性检查，例如AUC、Calibration、NE等指标的计算确认等。如果是模型上线前出了问题，可以邮件通知，如果是用户正在使用的模型出了问题，就需要电话通知了。")]),v._v(" "),_("h4",{attrs:{id:"rule-10-注意隐蔽性的失败"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-10-注意隐蔽性的失败"}},[v._v("#")]),v._v(" Rule #10: 注意隐蔽性的失败")]),v._v(" "),_("p",[v._v("这是一个非常重要，而又经常容易被忽略的问题。所谓的隐蔽性失败指的是全部流程都正常完成，但是背后依赖数据出了问题，导致模型效果逐步下降的问题。这种问题在其他系统中并不常出现（某些错误是不会有类似程序出错的异常），但是在机器学习系统中出现几率会比较高。例如训练依赖的某张数据表很久没有更新了，或者表中的数据含义发生了变化等，再或者数据的覆盖度忽然变少，都会对效果产生很大的影响。解决方法是是对关键数据的统计信息进行监控，并且周期性对关键数据进行人工检查。")]),v._v(" "),_("h4",{attrs:{id:"rule-11-文档化每个特征及其维护者"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-11-文档化每个特征及其维护者"}},[v._v("#")]),v._v(" Rule #11: 文档化每个特征及其维护者")]),v._v(" "),_("p",[v._v("如果系统庞大，数据繁多，那么知道每组数据由谁生成就变得非常重要。虽然数据都有简单描述，但是关于特征的具体计算逻辑，数据来源等都需要更详细的记录。")]),v._v(" "),_("h3",{attrs:{id:"第一个目标"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第一个目标"}},[v._v("#")]),v._v(" 第一个目标")]),v._v(" "),_("p",[v._v("objective是模型试图优化的值，而metric指的是任何用来衡量系统的值。")]),v._v(" "),_("h4",{attrs:{id:"rule-12-不要过于纠结该优化哪个目标"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-12-不要过于纠结该优化哪个目标"}},[v._v("#")]),v._v(" Rule #12: 不要过于纠结该优化哪个目标")]),v._v(" "),_("p",[v._v("机器学习上线的初期，即使你只优化一个目标，很多指标一般都会一起上涨的。所以不用太纠结究竟该优化哪个。")]),v._v(" "),_("p",[v._v("虽然大佬这么说，但是在实际的场景中，只优化一个目标，系统的整体效果却未必会上涨。典型的如推荐系统的CTR模型，上线之后CTR确实会提升，但是对应的CVR很有可能会下降，这时还需要一个CVR模型，两个模型同时使用才能真正提升系统效果。究其原因，是因为每个目标只关注系统整个过程的一个子过程，贪心地去优化这个子过程，不一定能够得到全局的最优解，通常需要把主要的几个子过程都优化之后，才能取得整体效果的提升。")]),v._v(" "),_("h4",{attrs:{id:"rule-13-选择简单、可观察、可归因的指标-metric-作为第一个优化目标-objective"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-13-选择简单、可观察、可归因的指标-metric-作为第一个优化目标-objective"}},[v._v("#")]),v._v(" Rule #13: 选择简单、可观察、可归因的指标（metric）作为第一个优化目标（objective）")]),v._v(" "),_("p",[v._v("objective应该是简单可衡量的，并且是metric的有效代理。最适合被建模的是可直接观测并被归因的行为，例如：")]),v._v(" "),_("ul",[_("li",[v._v("链接是否被点击？")]),v._v(" "),_("li",[v._v("软件是否被下载？")]),v._v(" "),_("li",[v._v("邮件是否被转发？")]),v._v(" "),_("li",[v._v("……")])]),v._v(" "),_("p",[v._v("尽量不要在第一次就建模非直接效果的行为，例如：")]),v._v(" "),_("ul",[_("li",[v._v("用户第二天是否会访问？")]),v._v(" "),_("li",[v._v("用户在网站上停留了多久？")]),v._v(" "),_("li",[v._v("日活用户有多少？")])]),v._v(" "),_("p",[v._v("非直接指标是很好的metric，可以用ABTest来进行观测，但不适合用作优化指标。此外，千万不要试图学习以下目标：")]),v._v(" "),_("ul",[_("li",[v._v("用户对产品是否满意？")]),v._v(" "),_("li",[v._v("用户对体验是否满意？")]),v._v(" "),_("li",[v._v("产品是否改善了用户的整体幸福感？")]),v._v(" "),_("li",[v._v("这将如何影响公司的整体健康？")]),v._v(" "),_("li",[v._v("……")])]),v._v(" "),_("p",[v._v("这些指标非常重要，但是非常难以学习。应该使用一些代理指标来学习，通过优化代理指标来优化这些非直接指标。为了公司的发展着想，最好有人工来连接机器学习的学习目标和产品业务。")]),v._v(" "),_("h4",{attrs:{id:"rule-14-尽量使用可解释的模型-以便于调试"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-14-尽量使用可解释的模型-以便于调试"}},[v._v("#")]),v._v(" Rule #14: 尽量使用可解释的模型，以便于调试")]),v._v(" "),_("p",[v._v("优先选择预测结果有概率含义、预测过程可解释的模型，可以更容易的确认效果，debug问题。例如，如果使用LR做分类，那么预测过程不外乎一些相乘和相加，如果特征都做了离散化，就只有加法了，这样很容易debug一条样本的预测得分是如何被计算出来的。所以出了问题很容易debug。")]),v._v(" "),_("h4",{attrs:{id:"rule-15-对垃圾邮件过滤和质量排序-在策略上要区分开"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-15-对垃圾邮件过滤和质量排序-在策略上要区分开"}},[v._v("#")]),v._v(" Rule #15: 对垃圾邮件过滤和质量排序，在策略上要区分开")]),v._v(" "),_("p",[v._v("排序系统工作的环境中数据分布是相对静态的，大家为了得到更好的排序，会遵守系统制定的规则。但是垃圾过滤更多是个对抗性质的工作，数据分布会经常变动。所以不应该让排序系统去处理垃圾信息的过滤，而是应该有单独的一层去处理垃圾信息。这也是一种可以推广的思想，那就是：排序层只做排序层的事情，职责尽量单一，其他工作让架构上更合适的模块去处理。此外，为了提升模型效果，应该把垃圾信息从训练数据中去除。")]),v._v(" "),_("h2",{attrs:{id:"机器学习的第二阶段-特征工程-feature-engineering"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#机器学习的第二阶段-特征工程-feature-engineering"}},[v._v("#")]),v._v(" 机器学习的第二阶段: 特征工程（Feature Engineering）")]),v._v(" "),_("p",[v._v("前面第一阶段的重点是把数据喂到学习系统中，有了基础的监控指标，有了基础的架构。等这一套系统建立起来后，第二阶段就开始了。")]),v._v(" "),_("p",[v._v("整体来讲，第二阶段的核心工作是将尽量多的有效特征加入到第一版的系统中，一般都可以取得提升。")]),v._v(" "),_("h4",{attrs:{id:"rule-16-做好持续迭代上线的准备"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-16-做好持续迭代上线的准备"}},[v._v("#")]),v._v(" Rule #16: 做好持续迭代上线的准备")]),v._v(" "),_("p",[v._v("简单来说，就是要深刻认识到，系统优化永远没有终点，所以系统设计方面要对迭代非常友好。例如增加删除特征是否足够简单，正确性验证是否足够简单，模型迭代是否可以并行运行，等等。")]),v._v(" "),_("p",[v._v("这虽然不是一条具体可行动的（actionable）规则，但是这种思想上的准备对整个系统的开发很有帮助。只有真正深刻意识到了系统持续迭代上线的本质，才会在设计在线和离线架构时为持续迭代最好相应的设计，并做好相应的工具，而不是做一锤子系统。")]),v._v(" "),_("h4",{attrs:{id:"rule-17-优先使用可直接观察或者记录的特征-而不是算法学习得到的特征"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-17-优先使用可直接观察或者记录的特征-而不是算法学习得到的特征"}},[v._v("#")]),v._v(" Rule #17: 优先使用可直接观察或者记录的特征（而不是算法学习得到的特征）")]),v._v(" "),_("p",[v._v("所谓学习出来的特征，指的是用另外的算法学习出来的特征，而非可以直接观测或收集到的简单特征。学习出来的特征由于存在外部依赖，或者计算逻辑复杂，不一定适用于你当前的模型，所以稳定性和有效性会有风险。而直接可观测的特征由于是相对比较客观的，依赖较少的，所以比较稳定。")]),v._v(" "),_("h4",{attrs:{id:"rule-18-挖掘能够在不同的上下文-场景-中泛化的特征"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-18-挖掘能够在不同的上下文-场景-中泛化的特征"}},[v._v("#")]),v._v(" Rule #18: 挖掘能够在不同的上下文（场景）中泛化的特征")]),v._v(" "),_("p",[v._v("中心思想是在说，要多利用可以在多个场景下使用的特征，例如全局的点击率、浏览量这些特征，可以在多个场景下作为特征使用。这样可以在一些冷启动或者缺乏有效特征的场景下作为特征使用。")]),v._v(" "),_("h4",{attrs:{id:"rule-19-尽可能使用具体的特征"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-19-尽可能使用具体的特征"}},[v._v("#")]),v._v(" Rule #19: 尽可能使用具体的特征")]),v._v(" "),_("p",[v._v("如评价博文的热度，首选博文近几天的浏览量，而不是博文表达的主题是不是流行。")]),v._v(" "),_("p",[v._v("所谓非常具体，指的是覆盖样本量比较少的特征，例如文档的ID或者query的ID等。这样的特征虽然每个只覆盖很少一部分特征，但是只要这一组特征整体能够覆盖率比较高，例如90%，那就是OK的。而且还可以通过正则化来消除覆盖率过低或者相关性差的特征。这也是大家都偏爱大规模ID特征的一个原因，现在很多大厂的排序模型特征都大量使用了大规模ID特征。")]),v._v(" "),_("h4",{attrs:{id:"rule-20-使用可理解的方式修改或组合新特征"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-20-使用可理解的方式修改或组合新特征"}},[v._v("#")]),v._v(" Rule #20: 使用可理解的方式修改或组合新特征")]),v._v(" "),_("p",[v._v("如Titanic生存预测的数据中，姐妹个数+孩子个数表示家庭人口大小。")]),v._v(" "),_("p",[v._v("离散化和交叉是最常用的两种特征使用方式。其本质都是用特征工程的方式，在不改变使用模型本身的情况下增加模型的非线性。这两种方法本身没什么好说的，值得一致的是，在大规模ID类特征的交叉时，例如一段是query里的关键词，另一端是文档里的关键词，那就会产生很大量级的交叉特征，这时有两种处理方法：")]),v._v(" "),_("ul",[_("li",[v._v("点积。其实计算query和文档共同包含的关键词数量。")]),v._v(" "),_("li",[v._v("交集。每一维特征的含义是某个词同时出现在了query和文档中，同时出现则该维特征为1，否则为0。")])]),v._v(" "),_("p",[v._v("所谓“人类可理解的方式”，大概意思是离散化和交叉要基于对业务逻辑的理解，不能乱交叉。")]),v._v(" "),_("h4",{attrs:{id:"rule-21-线性模型中可学到的特征权重数量-与训练数据的数量大体成正比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-21-线性模型中可学到的特征权重数量-与训练数据的数量大体成正比"}},[v._v("#")]),v._v(" Rule #21: 线性模型中可学到的特征权重数量，与训练数据的数量大体成正比")]),v._v(" "),_("p",[v._v("这背后有复杂的统计原理做支撑，但你只需要知道结论就可以了。这个原则给我们的启示，是要根据数据量来选择特征的生成方式，例如：")]),v._v(" "),_("p",[v._v("如果你的系统是一个搜索系统，query和文档中有百万级的词，但是你只有千级别的标注样本。那你就别用ID级关键词特征了，而是要考虑点积类特征，把特征数量控制在几十个这个级别。\n如果你拥有百万级样本，那么可以将文档和query的关键词进行交叉特征，然后用正则化进行特征选择。这样你会得到百万级特征，但是正则化之后会更少。所以说，千万级样本，十万级特征。\n如果你有十亿级或者更高级别的样本，那么你可以使用query和文档的ID级特征，然后加上特征选择和正则化。十亿级样本，千万级特征。\n总结起来就是，根据样本决定特征使用方式，样本不够就对特征进行高层次抽象处理，指导和样本量级相匹配。")]),v._v(" "),_("h4",{attrs:{id:"rule-22-清除掉不会再使用的特征"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-22-清除掉不会再使用的特征"}},[v._v("#")]),v._v(" Rule #22: 清除掉不会再使用的特征")]),v._v(" "),_("p",[v._v("如果某个特征已经没有用，并且它与其他特征的交叉也已经没有用，就应该将其清理掉，保持架构的整洁性。")]),v._v(" "),_("p",[v._v("在考虑添加或保留哪些特征时，需要统计一下特征的样本覆盖率，例如一些整体覆盖率很低的个性化feature column，只有很少用户能覆盖到，那么大概率这组特征作用不大。但另一方面，如果某个特征覆盖率很低，例如只有1%，但是其区分度非常大，例如90%取值为1的样本都是正样本，那么 这个特征就值得加入或保留。")]),v._v(" "),_("h2",{attrs:{id:"系统的人工分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#系统的人工分析"}},[v._v("#")]),v._v(" 系统的人工分析")]),v._v(" "),_("p",[v._v("在进入机器学习的第三阶段之前，有必要关注一下机器学习课程中都没有教授的内容：如何审视现有模型，并对其进行改进。这与其说是一门科学，不如说是一门艺术，然而有几个反模式是有助于这种改进的。")]),v._v(" "),_("h4",{attrs:{id:"rule-23-个人不能代表大多数的用户"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-23-个人不能代表大多数的用户"}},[v._v("#")]),v._v(" Rule #23: 个人不能代表大多数的用户")]),v._v(" "),_("p",[v._v("所以你不能代表用户做判断模型的表现好坏，要做A/B Test。")]),v._v(" "),_("h4",{attrs:{id:"rule-24-评估模型间的差异"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-24-评估模型间的差异"}},[v._v("#")]),v._v(" Rule #24: 评估模型间的差异")]),v._v(" "),_("p",[v._v("在任何用户看过你的新模型之前，你可以做的一个最简单的，有时也是最有用的评估，就是计算新模型的结果与生产中的差异有多大。例如，如果你有一个排名问题，在整个系统的查询样本上运行两个模型，看看结果的对称性差异的大小（按排名位置加权）。如果差异非常小，那么你可以不用运行实验就知道会有很小的变化。如果差异非常大，那么你要确保这种变化是好的。查看对称性差异大的查询，可以帮助你从质量上了解变化是怎样的。然而，要确保系统是稳定的。确保一个模型在与自己比较时有一个低的（最好是零的）对称性差异。")]),v._v(" "),_("h4",{attrs:{id:"rule-25-选择模型时-实用性比预测能力更重要"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-25-选择模型时-实用性比预测能力更重要"}},[v._v("#")]),v._v(" Rule #25: 选择模型时，实用性比预测能力更重要")]),v._v(" "),_("p",[v._v("如果模型不能达到业务的性能要求，即使指标再高也不会让你上线的。")]),v._v(" "),_("h4",{attrs:{id:"rule-26-观察模型误判的数据-寻找规律-抽取新特征"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-26-观察模型误判的数据-寻找规律-抽取新特征"}},[v._v("#")]),v._v(" Rule #26: 观察模型误判的数据，寻找规律，抽取新特征")]),v._v(" "),_("p",[v._v("假设你看到一个被模型“搞错”的训练实例。在分类任务中，这个错误可能是一个假阳性或假阴性。在一个排名任务中，这个错误可能是一对正数的排名低于负数。最重要的一点是，这是一个机器学习系统知道自己错了的实例，如果有机会的话，它希望能够修复。如果你给模型一个允许它修复错误的特征，模型就会尝试使用它。")]),v._v(" "),_("h4",{attrs:{id:"rule-27-量化观察到的不利行为"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-27-量化观察到的不利行为"}},[v._v("#")]),v._v(" Rule #27: 量化观察到的不利行为")]),v._v(" "),_("p",[v._v('你的团队中的一些成员会对他们不喜欢的系统的属性感到沮丧，而这些属性并没有被现有的损失函数所捕获。在这一点上，他们应该不惜一切代价，将他们的不满转化为可靠的数字。例如，如果他们认为Play Search中显示了太多的 "插科打诨的应用程序"，他们可以让人工识别插科打诨的应用程序。(在这种情况下，你可以可行地使用人工标记的数据，因为相对较小的一部分查询占了很大一部分流量）。如果你的问题是可度量的，那么你就可以开始使用它们作为特征、目标或衡量标准。一般的规则是 "先测量，后优化"。')]),v._v(" "),_("h4",{attrs:{id:"rule-28-注意区分短期行为和长期行为"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-28-注意区分短期行为和长期行为"}},[v._v("#")]),v._v(" Rule #28: 注意区分短期行为和长期行为")]),v._v(" "),_("p",[v._v("如端午节很多人在购物中购买粽子，这并不代表这些人是个吃货，为此专门构造特征表示购买粽子的行为是不合适的。")]),v._v(" "),_("h2",{attrs:{id:"训练偏差-training-serving-skew"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#训练偏差-training-serving-skew"}},[v._v("#")]),v._v(" 训练偏差（Training-Serving Skew）")]),v._v(" "),_("p",[v._v("训练偏差是训练时的表现与线上预测（服务）时的表现之间的差异。这种偏差可能是由以下原因造成的：")]),v._v(" "),_("ul",[_("li",[v._v("你在训练和服务管道中处理数据的方式存在差异。")]),v._v(" "),_("li",[v._v("训练时和服务时的数据变化。")]),v._v(" "),_("li",[v._v("你的模型和你的算法之间的反馈回路。")])]),v._v(" "),_("p",[v._v("我们已经观察到谷歌的生产机器学习系统在训练和服务方面存在偏差，对性能产生了负面影响。最好的解决方案是明确地监控它，这样系统和数据的变化就不会在不知不觉中引入偏斜。")]),v._v(" "),_("h4",{attrs:{id:"rule-29-为保证服务和训练效果相同-最好将服务时的特征集合保存以作训练"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-29-为保证服务和训练效果相同-最好将服务时的特征集合保存以作训练"}},[v._v("#")]),v._v(" Rule #29: 为保证服务和训练效果相同，最好将服务时的特征集合保存以作训练")]),v._v(" "),_("p",[v._v("即使你不能对每个样本都这样做，也要对一小部分做，这样你就能验证服务和训练之间的一致性（"),_("a",{attrs:{href:""}},[v._v("见Rule #37")]),v._v("）。在谷歌进有专门执行这种测试的团队，有时会对结果感到惊讶。YouTube主页在服务时改用日志功能，质量明显提高，代码复杂度也降低。")]),v._v(" "),_("h4",{attrs:{id:"rule-30-对采样样本加权而不是随意丢弃"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-30-对采样样本加权而不是随意丢弃"}},[v._v("#")]),v._v(" Rule #30: 对采样样本加权而不是随意丢弃")]),v._v(" "),_("p",[v._v("这是作者唯一用了感叹号的一条，可想而知背后的辛酸。当我们有太多训练数据时，我们会只取其中的一部分。但这是错误的。正确的做法是，如果你给某条样本30%的采样权重，那么在训练时就给它10/3的训练权重。通过这样的重要性赋权（importance weight），整个训练结果的校准性（calibration）就还能够保证。")]),v._v(" "),_("p",[v._v("多说一句，这个校准性非常的重要，尤其对于广告系统，或者多个预测值相加或相乘来得到最终结果的系统。如果单个值没有校准，偏低或偏高，那么在相乘或相加之后其含义就会不正确。如果直接使用模型预测值进行排序，校准性就没那么重要，因为校准性不会影响排序，只会影响具体的值。")]),v._v(" "),_("h4",{attrs:{id:"rule-31-模型训练之后才上线-在此过程中数据有可能已经发生变化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-31-模型训练之后才上线-在此过程中数据有可能已经发生变化"}},[v._v("#")]),v._v(" Rule #31: 模型训练之后才上线，在此过程中数据有可能已经发生变化")]),v._v(" "),_("p",[v._v("如果训练特征有一个特征表示博文的浏览量，那么等到模型训练完，浏览量已经发生变化了。")]),v._v(" "),_("p",[v._v("比如说某张表里存着一些文档的特征，你在离线训练之前要去这个表里取这些特征用来训练，但这里就有个风险，那就是这个表里的数据在你离线取的时候和在线服务的时候数据不一样，发生了变化。最好的解决方式就是在服务端将特征记录在日志中，这样能保证数据的一致性。或者如果这张表的变化频率比较低，也可以考虑对其做小时级或天级备份，以此来减少这种差异。但要记住这种方法并不能彻底解决这个问题。")]),v._v(" "),_("h4",{attrs:{id:"rule-32-尽可能在训练和服务时复用代码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-32-尽可能在训练和服务时复用代码"}},[v._v("#")]),v._v(" Rule #32: 尽可能在训练和服务时复用代码")]),v._v(" "),_("p",[v._v("训练一般是离线批量进行的，而服务则是在线流式进行的，这两者之间虽然在处理数据的方式上存在着较大差异，但仍然有很多代码可以共享。这些代码的共享可以从代码层面介绍训练和服务之间的差异。换句话说，日志记录特征是从数据角度消除差异，那么代码复用就是从代码角度消除差异，双管齐下，效果更好。")]),v._v(" "),_("h4",{attrs:{id:"rule-33-使用不同时期的数据集做训练和测试"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-33-使用不同时期的数据集做训练和测试"}},[v._v("#")]),v._v(" Rule #33: 使用不同时期的数据集做训练和测试")]),v._v(" "),_("p",[v._v("如果训练数据是1月5日之前的，那么测试数据要从1月6日开始。\n这条规则的主要目的是让测试结果与线上结果更加接近，因为我们在使用模型时就是在用服务当天之前的数据训练，然后来预测当天的数据。这样得到的测试结果虽然可能会偏低，但却更加接近实际场景。")]),v._v(" "),_("h4",{attrs:{id:"rule-34-在为过滤服务的二分类问题中-例如垃圾邮件过滤-可以为了干净的数据牺牲一些短期效果。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-34-在为过滤服务的二分类问题中-例如垃圾邮件过滤-可以为了干净的数据牺牲一些短期效果。"}},[v._v("#")]),v._v(" Rule #34: 在为过滤服务的二分类问题中（例如垃圾邮件过滤），可以为了干净的数据牺牲一些短期效果。")]),v._v(" "),_("p",[v._v("在过滤类的任务中，被标记为负的样本是不会展示给用户的，例如可能会把75%标记为负的样本阻拦住不展现给用户。但如果你只从展示给用户的结果中获取下次训练的样本，显然你的训练样本是有偏的。")]),v._v(" "),_("p",[v._v("更好的做法是使用一定比例的流量（例如1%）专门收集训练数据，在这部分流量中的用户会看到所有的样本。这样显然会影响线上的真实过滤效果，但是会收集到更好的数据，更有利于系统的长远发展。否则系统会越训练越偏，慢慢就不可用了。同时还能保证至少过滤掉74%的负样本，对系统的影响也不是很大。")]),v._v(" "),_("p",[v._v("但是如果你的系统会过滤掉95%或者更多的负样本，这种做法就不那么可行了。即使如此，为了准确衡量模型的效果，你仍然可以通过构造一个更小的数据集（0.1%或者更小）来测试。十万级别的样本足够给出准确的评价指标了。")]),v._v(" "),_("h4",{attrs:{id:"rule-35-注意排序问题中固有的数据偏置"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-35-注意排序问题中固有的数据偏置"}},[v._v("#")]),v._v(" Rule #35: 注意排序问题中固有的数据偏置")]),v._v(" "),_("p",[v._v("如下载排行榜中靠前的APP在本质上就诱导用户下载。")]),v._v(" "),_("p",[v._v("当新的排序算法对线上排序结果产生了重大改变时，你其实是改变了算法将来会看到的数据。这时这种偏置就会出现。这种问题有以下几种方法来解决，核心思想都是更偏重模型已经看到过的数据。")]),v._v(" "),_("ul",[_("li",[v._v("对覆盖更多query（或类似角色，根据业务不同）的特征给予更强的正则化。这样模型会更偏重只覆盖一部分样本的特征，而不是泛化性特征。这样会阻止爆品出现在不相关query的结果中。")]),v._v(" "),_("li",[v._v("只允许特征取正的权重值。这样任何好特征都会比“未知”特征要好。")]),v._v(" "),_("li",[v._v("不要使用只和文档相关的特征。这是第一条的极端情况，否则会导致类似哈利波特效应的情况出现，也就是一条在任何query下都受欢迎的文档不会到处都出现。去除掉只和文档相关的特征会阻止这种情况发生。")])]),v._v(" "),_("h4",{attrs:{id:"rule-36-避免使用位置特征的反馈回路"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-36-避免使用位置特征的反馈回路"}},[v._v("#")]),v._v(" Rule #36: 避免使用位置特征的反馈回路")]),v._v(" "),_("p",[v._v("大家都知道排序位置本身就会影响用户是否会对物品产生互动，例如点击。所以如果模型中没有位置特征，本来由于位置导致的影响会被算到其他特征头上去，导致模型不够准。可以用加入位置特征的方法来避免这种问题，具体来讲，在训练时加入位置特征，预测时去掉位置特征，或者给所有样本一样的位置特征。这样会让模型更正确地分配特征的权重。")]),v._v(" "),_("p",[v._v("需要注意的是，位置特征要保持相对独立，不要与其他特征发生关联。可以将位置相关的特征用一个函数表达，然后将其他特征用另外的函数表达，然后组合起来。具体应用中，可以通过位置特征不与任何其他特征交叉来实现这个目的。")]),v._v(" "),_("h4",{attrs:{id:"rule-37-评估训练和服务之间的偏差"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-37-评估训练和服务之间的偏差"}},[v._v("#")]),v._v(" Rule #37: 评估训练和服务之间的偏差")]),v._v(" "),_("p",[v._v("整体来讲有多种原因会导致这种差异，我们可以将其进行细分为以下几部分：")]),v._v(" "),_("ul",[_("li",[v._v("训练集和测试集之间的差异。这种差异会经常存在，而且不一定是坏事。")]),v._v(" "),_("li",[v._v("测试集和“第二天”数据间的差异。这种差异也会一直存在，而这个“第二天”数据上的表现是我们应该努力优化的，例如通过正则化。这两者之间差异如果过大，可能是因为用到了一些时间敏感的特征，导致模型效果变化明显。")]),v._v(" "),_("li",[v._v("“第二天”数据和线上数据间的差异。如果同样一条样本，在训练时给出的结果和线上服务时给出的结果不一致，那么这意味着工程实现中出现了bug。")])]),v._v(" "),_("h2",{attrs:{id:"机器学习的第三阶段-缓慢提升、精细优化、复杂模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#机器学习的第三阶段-缓慢提升、精细优化、复杂模型"}},[v._v("#")]),v._v(" 机器学习的第三阶段：缓慢提升、精细优化、复杂模型")]),v._v(" "),_("p",[v._v("标题已经在说明即将接近尾声了，接下来可能没有之前进步的那样快了。首先，你需要在metics之间做tradeoff：一些指标精度的提高可能会造成其他指标的下降。机器学习会变得更加复杂。事先声明：本节给出的规则是开放性的，许多team可以从上两个阶段获益颇多，但是在第三阶段，他们不得不找出适合自己的方法。")]),v._v(" "),_("h4",{attrs:{id:"rule-38-如果objective没有达成一致-不要在新特征上浪费时间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-38-如果objective没有达成一致-不要在新特征上浪费时间"}},[v._v("#")]),v._v(" Rule #38: 如果objective没有达成一致，不要在新特征上浪费时间")]),v._v(" "),_("p",[v._v("当系统整体达到一个稳定期，大家会开始关注机器学习系统优化目标以外的一些问题。这个时候，目标就不如之前那么清晰，那么如果目标没有确定下来的话，先不要在特征上浪费时间。")]),v._v(" "),_("h4",{attrs:{id:"rule-39-线上决策是长期产品-项目目标的代理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-39-线上决策是长期产品-项目目标的代理"}},[v._v("#")]),v._v(" Rule #39: 线上决策是长期产品/项目目标的代理")]),v._v(" "),_("p",[v._v("这句话读起来有点别扭，作者举了几个例子来说明，核心就是在讲一件事情：系统、产品甚至公司的长远发展需要通过多个指标来综合衡量，而新模型是否上线要综合考虑这些指标。所谓代理，指的就是优化这些综合指标就是在优化产品、公司的长远目标。")]),v._v(" "),_("p",[v._v("决策只有在所有指标都在变好的情况下才会变得简单。但常常事情没那么简单，尤其是当不同指标之间无法换算的时候，例如A系统有一百万日活和四百万日收入，B系统有两百万日活和两百万日收入，你会从A切换到B吗？或者反过来？答案是或许都不会，因为你不知道某个指标的提升是否会cover另外一个指标的下降。")]),v._v(" "),_("p",[v._v("关键是，没有任何一个指标能回答：“五年后我的产品在哪里”？")]),v._v(" "),_("p",[v._v("而每个个体，尤其是工程师们，显然更喜欢能够直接优化的目标，而这也是机器学习系统常见的场景 。现在也有一些多目标学习系统在试图解决这种问题。但仍然有很多目标无法建模为机器学习问题，比如用户为什么会来访问你的网站等等。作者说这是个AI-complete问题，也常被称为强AI问题，简单来说就是不能用某个单一算法解决的问题。")]),v._v(" "),_("h4",{attrs:{id:"rule-40-保持集成模型simple"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-40-保持集成模型simple"}},[v._v("#")]),v._v(" Rule #40: 保持集成模型Simple")]),v._v(" "),_("p",[v._v("什么叫简单的ensemble？作者认为，只接受其他模型的输出作为输入，不附带其他特征的ensemble，叫做简单的ensemble。换句话说，你的模型要么是单纯的ensemble模型，要么是普通的接收大量特征的基模型。即每个模型只能选择其一：只接收其他模型输入或只接收原始特征，不能两者兼有。")]),v._v(" "),_("p",[v._v("除了保持简单，ensemble模型最好还能具有一些良好的性质。例如，某个基模型的性能提升不能降低组合模型的性能。以及，基模型最好都是可解释的（例如是校准的)，这样基模型的变化对上层的组合模型来说也是可解释的。同时，一个基模型预测概率值的提升不会降低组合模型的预测概率值。")]),v._v(" "),_("h4",{attrs:{id:"rule-41-当性能平稳后-寻找本质上新的信息源-而不是优化已有的信号"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-41-当性能平稳后-寻找本质上新的信息源-而不是优化已有的信号"}},[v._v("#")]),v._v(" Rule #41: 当性能平稳后，寻找本质上新的信息源，而不是优化已有的信号")]),v._v(" "),_("p",[v._v("你加了一些用户的人口统计学特征、一些文档的文字特征，等等，但是关键指标上的提升还不到1%。现在咋整？")]),v._v(" "),_("p",[v._v("这时就应该考虑加一些根本上不同的特征，例如用户再过去一天、一周看过的文档历史，或者另外一个数据源的数据。总之，要加入完全不同的维度的特征。此外也可以尝试使用深度学习，但同时也要调整你对ROI的预期，并且要评估增加的"),_("strong",[v._v("复杂度")]),v._v("换来的收益是否值得。")]),v._v(" "),_("h4",{attrs:{id:"rule-42-多样性-个性化或者相关性与流行度的相关性关系可能要比你想的弱很多"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-42-多样性-个性化或者相关性与流行度的相关性关系可能要比你想的弱很多"}},[v._v("#")]),v._v(" Rule #42: 多样性，个性化或者相关性与流行度的相关性关系可能要比你想的弱很多")]),v._v(" "),_("p",[v._v("多样性意味着内容或者来源的多样性；个性化意味着每个用户得到不一样的东西；相关性意味着一个query的返回结果相比其他query与这个query更相关。")]),v._v(" "),_("p",[v._v("如果你的衡量指标是点击、停留时长、观看数、分享数等等，你本质上是在衡量东西的流行度。有的团队有时会希望学到一个多样化的个性化模型。为此，会加入个性化特征和多样化特征，但是最后会发现这些特征并没有得到预期的权重。")]),v._v(" "),_("p",[v._v("这并不能说明多样性、个性化和相关性不重要，而是可以通过后处理来提高或者根据多样性和相关性改进目标。如果这时看到长期目标提升了，你就可以确定多样性/相关性是有用的。这时你就可以选择继续使用后续处理的方式，或者根据多样性和相关性直接修改要优化的objective。")]),v._v(" "),_("h4",{attrs:{id:"rule-43-你在不同产品上的好友一般是一样的-但你的兴趣表现通常会不一样"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rule-43-你在不同产品上的好友一般是一样的-但你的兴趣表现通常会不一样"}},[v._v("#")]),v._v(" Rule #43: 你在不同产品上的好友一般是一样的，但你的兴趣表现通常会不一样")]),v._v(" "),_("p",[v._v("谷歌经常在不同产品上使用同样的好友关系预测模型，并且取得了很好的效果，这证明不同的产品上好友关系是可以迁移的，毕竟他们是固定的同一批人。但他们尝试将一个产品上的个性化特征使用到另外一个产品上时却常常得不到好结果。可行的做法是使用一个数据源上的原始数据来预测另外数据源上的行为，而不是使用加工后的特征。此外，用户在另一个数据源上的行为历史也会有用。")]),v._v(" "),_("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),_("p",[v._v("作者Martin Zinkevich认为，对于大多数机器学习应用场景来说，我们需要解决的问题大多数都是工程问题，解决这些工程问题需要的并不是复杂的理论，更多是对细节、架构、过程的仔细推敲和精致追求。而这些是非大神的普通人可以做到的，需要对工程架构、过程和细节做好足够和持续的优化。")])])}),[],!1,null,null,null);_.default=e.exports}}]);